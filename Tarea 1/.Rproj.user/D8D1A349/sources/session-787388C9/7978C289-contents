pacman::p_load(dplyr,psych,ggplot2,tidyverse,proxy,dplyr,umap, ggdendro, cluster)

data<-read.csv("datos_t1_centroides.csv",sep=",",header=TRUE)
#Analisis de datos nulos.

sum(is.na(data))

Tuplas_na<-sum(apply(X=is.na(data),MARGIN=1,FUN =sum)>0)
Tuplas_na
Tuplas_na*100/1661
#12.5 % de las tuplas tienen nulos.

Column_na<-sum(apply(X=is.na(data),MARGIN=2,FUN =sum)>0)
#11 columnas presentan NA

#True/falso presencia nulos por columna/fila
valores_col<-apply(X=is.na(data),MARGIN=2,FUN =sum)>0
valores_tu<-apply(X=is.na(data),MARGIN=1,FUN =sum)>0

#columnas con su respectivo numero de nulos
apply(X=is.na(data),MARGIN=2,FUN =sum)[valores]

#Filas con su respectivo indice y n°de nulo
indice_nulos<-cbind(rownames(data)[valores_tu],apply(X=is.na(data),MARGIN=1,FUN =sum)[valores_tu])
valores_1<-apply(X=is.na(data),MARGIN=1,FUN =sum)>1

#se sacan las filas con n°de nulos mayor a 1.
indices_e<-c(row.names(data)[!(valores_1)])
indices_e
#vemos que la cantidad de nulos sobrante es de 28, correspondiente a la columan ise.
#Es mejor eliminar 28 filas, que eliminar esa columna y perder los demás datos.
data2<-data[indices_e,]
apply(X=is.na(data2),MARGIN=2,FUN =sum)
#data_final
data_final<-data[c(row.names(data)[!(valores_tu)]),]
apply(X=is.na(data_final),MARGIN=2,FUN =sum)


#Estadistica Descriptiva.
str(data)
#Notamos que las variables X1., cod_com, COMUNA, MANZ_EN no aportan valores diferentes.
unique(data["COMUNA"])
unique(data["cod_com"])
unique(data["MANZ_EN"])
#eliminamos X1 por ser los indices y las demás columnas por ser el mismo valor para todos los datos.
data_final$X.1<-NULL
data_final$COMUNA<-NULL
data_final$cod_com<-NULL
data_final$MANZ_EN<-NULL
#Analisis duplicados: No hay filas duplicadas.
sum(duplicated(data_final))
#Analisis de variables
str(data_final)
count(unique(data["ZONA"]))

#Boxplots, revisar outliers.
columnas<-colnames(data_final)
columnas[29:35]
outliers<-c()
boxplot(data_final["iav"])$out
for(i in colnames(data_final)){
  caja<-boxplot(data_final[i],main=i)
  caja
  #caja$out
}
#

#generar una data que disminuya los computos, evaluar similitud y correlación.
muestra<-data_final %>%
  select(dim_acc, iav, icul,idep,isal,iser,ise) %>% 
  sample_n(500)
simil(list(muestra$dim_acc,muestra$iav), method="pearson")
simil(list(muestra$dim_acc,muestra$icul), method="pearson")
simil(list(muestra$dim_acc,muestra$idep), method="pearson")
simil(list(muestra$dim_acc,muestra$isal), method="pearson")
simil(list(muestra$dim_acc,muestra$iser), method="pearson")
simil(list(muestra$dim_acc,muestra$ise), method="pearson")
cor(muestra, method="pearson")

muestra<-data_final %>%
  select(dim_amb, iata, icv) %>% 
  sample_n(500)
simil(list(muestra$dim_amb,muestra$iata), method="pearson")
simil(list(muestra$dim_amb,muestra$icv), method="pearson")
cor(muestra, method = "pearson")

# analisis de clusters naturales ----
pacman::p_load(magick, factoextra)

get_clust_tendency(data_final[,1:35], n = 13, graph = FALSE)

model.umap <- umap(data_final[,1:35])

data.umap <- 
  model.umap$layout %>% 
  as.data.frame()

get_clust_tendency(data.umap, n = 13, graph = FALSE)

ggplot(data.umap, aes(V1, V2)) + 
  geom_point()

modelo1<-kmeans(data.umap,13)
ggplot(data.umap) +
  geom_point(aes(V1,V2, col=factor(modelo1$cluster))) +
  theme()

model.umap <- umap(data_final)
data.umap <- 
  model.umap$layout %>% 
  as.data.frame()
modelo2<-kmeans(data.umap,13)
ggplot(data.umap) +
  geom_point(aes(V1,V2, col=factor(modelo2$cluster))) +
  theme()

#Umap: reproyección no lineal de los datos.
#PCA: reproyección lineal de los datos. Umap lo hace similar pero no lineal.
model.umap <- umap(data_final[,1:35])

data.umap <- 
  model.umap$layout %>% 
  as.data.frame()
# exploramos la data 
data.umap %>% summary()

# exploramos graficamente la data

ggplot(data.umap) +
  geom_point(aes(V1,V2))

#para clusterizar:
distancia <- dist(data.umap)
model_complete <- hclust(distancia, method="complete")
summary(model_complete)
plot(model_complete)

groups <- cutree(model_complete, h = 21.25)  
groups %>% unique() %>% length()


# visualizamos los grupos resultantes
ggplot(data.umap) +
  geom_point(aes(V1,V2, col=factor(groups))) +
  theme()

